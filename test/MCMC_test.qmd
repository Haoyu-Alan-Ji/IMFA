---
title: "MCMC"
author: "Haoyu Ji"
format: 
  html:
    code-tools: true
    df-print: paged
    self-contained: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
if (!requireNamespace("here", quietly = TRUE)) install.packages("here")
setwd(here::here())
```


```{r}
############################################################
# Toy IMFA: one full MCMC sweep (p=q=1, N=3)
# Slice sampling + (DP) stick-breaking + FA conjugate updates
# (All "random draws" are fixed to reproduce the worked example)
############################################################

options(digits = 10)

cat("=== 0) Data and hyperparameters ===\n")
x1 <- -1.0
x2 <-  0.2
x3 <-  1.3
cat("x = (", x1, ", ", x2, ", ", x3, ")\n\n", sep = "")

# Priors:
# mu_g ~ N(0,1), lambda_g ~ N(0,1), psi_g ~ IG(a0=2, b0=1)
a0 <- 2
b0 <- 1

# Slice xi_g: rho = 0.5, xi_g = (1-rho) rho^(g-1) = 0.5 * 0.5^(g-1)
rho <- 0.5
xi_all <- (1 - rho) * rho^(0:9)  # xi_1..xi_10
cat("xi_1..xi_4 = ", xi_all[1], ", ", xi_all[2], ", ", xi_all[3], ", ", xi_all[4], "\n\n", sep = "")

# DP stick-breaking (PYP with d=0), alpha fixed
alpha <- 1

cat("=== 1) Initial state at start of iteration ===\n")
# initial allocations
z1 <- 1
z2 <- 1
z3 <- 2
cat("z = (", z1, ", ", z2, ", ", z3, ")\n", sep = "")

# initial factor scores
eta1 <-  0.3
eta2 <- -0.1
eta3 <-  0.2
cat("eta = (", eta1, ", ", eta2, ", ", eta3, ")\n", sep = "")

# initial cluster params for g=1,2 (g=3 not instantiated yet)
mu    <- c(-0.5, 1.0, NA)
lambda<- c( 0.8, 0.5, NA)
psi   <- c( 0.4, 0.3, NA)
cat("Cluster 1: mu1=", mu[1], " lambda1=", lambda[1], " psi1=", psi[1], "\n", sep="")
cat("Cluster 2: mu2=", mu[2], " lambda2=", lambda[2], " psi2=", psi[2], "\n\n", sep="")

# initial stick-breaking v_g and implied pi_g for g=1..3
v <- c(0.6, 0.7, 0.5)  # fixed
pi1 <- v[1]
pi2 <- v[2] * (1 - v[1])
pi3 <- v[3] * (1 - v[1]) * (1 - v[2])
pi <- c(pi1, pi2, pi3)
cat("v = (", v[1], ", ", v[2], ", ", v[3], ")\n", sep="")
cat("pi = (", pi[1], ", ", pi[2], ", ", pi[3], ")\n\n", sep="")

############################################################
cat("=== Step A) Update slice variables u_i | z_i=g ~ Unif(0, xi_g) ===\n")
# Fixed "draws" to match the example
u1 <- 0.10  # from Unif(0, xi_1=0.5) because z1=1
u2 <- 0.44  # from Unif(0, xi_1=0.5) because z2=1
u3 <- 0.20  # from Unif(0, xi_2=0.25) because z3=2
cat("u = (", u1, ", ", u2, ", ", u3, ")\n\n", sep="")

############################################################
cat("=== Step B) Define A_xi(u_i) = {g: u_i < xi_g} ===\n")
# For decreasing xi_g, A_xi(u_i) is simply {1,2,...,K_i} where K_i = max{g: xi_g > u_i}
K1 <- max(which(xi_all > u1))
K2 <- max(which(xi_all > u2))
K3 <- max(which(xi_all > u3))

A1 <- 1:K1
A2 <- 1:K2
A3 <- 1:K3

cat("A_xi(u1=0.10) = ", paste(A1, collapse=","), "\n", sep="")
cat("A_xi(u2=0.44) = ", paste(A2, collapse=","), "\n", sep="")
cat("A_xi(u3=0.20) = ", paste(A3, collapse=","), "\n", sep="")

G_star <- max(K1, K2, K3)
cat("G* (max candidate cluster index this iter) = ", G_star, "\n\n", sep="")

############################################################
cat("=== Step C) Instantiate cluster 3 parameters (since it appears in candidates) ===\n")
# Fixed "prior draws" to match the example
mu[3]     <-  0.2
lambda[3] <- -0.4
psi[3]    <-  0.5
cat("Cluster 3: mu3=", mu[3], " lambda3=", lambda[3], " psi3=", psi[3], "\n\n", sep="")

############################################################
cat("=== Step D) Update z_i using slice-restricted categorical ===\n")
cat("Pr(z_i=g|.) âˆ (pi_g/xi_g)*1(u_i<xi_g)*N(x_i; mu_g+lambda_g*eta_i, psi_g)\n\n")

# Helper: pi_g / xi_g for g=1..3
xi <- xi_all[1:3]
coef <- pi / xi
cat("pi/xi = (", coef[1], ", ", coef[2], ", ", coef[3], ")\n\n", sep="")

#### D1) Update z1, candidates A1={1,2,3}
cat("--- D1) Update z1 ---\n")
x <- x1
eta <- eta1

m11 <- mu[1] + lambda[1]*eta
m12 <- mu[2] + lambda[2]*eta
m13 <- mu[3] + lambda[3]*eta

d11 <- dnorm(x, mean=m11, sd=sqrt(psi[1]))
d12 <- dnorm(x, mean=m12, sd=sqrt(psi[2]))
d13 <- dnorm(x, mean=m13, sd=sqrt(psi[3]))

w11 <- coef[1]*d11
w12 <- coef[2]*d12
w13 <- coef[3]*d13

wsum <- w11+w12+w13
p11 <- w11/wsum
p12 <- w12/wsum
p13 <- w13/wsum

cat("means: m11=", m11, " m12=", m12, " m13=", m13, "\n", sep="")
cat("dens : d11=", d11, " d12=", d12, " d13=", d13, "\n", sep="")
cat("w    : w11=", w11, " w12=", w12, " w13=", w13, "\n", sep="")
cat("P(z1=1)=", p11, " P(z1=2)=", p12, " P(z1=3)=", p13, "\n", sep="")

# Fixed uniform draw r1 = 0.90 (to match the example)
r1 <- 0.90
cdf1 <- c(p11, p11+p12, 1.0)
cat("cdf = (", cdf1[1], ", ", cdf1[2], ", 1)\n", sep="")
cat("r1 = ", r1, "\n", sep="")

if (r1 <= cdf1[1]) {
  z1_new <- 1
} else if (r1 <= cdf1[2]) {
  z1_new <- 2
} else {
  z1_new <- 3
}
cat("=> z1 <- ", z1_new, "\n\n", sep="")

#### D2) Update z2, candidates A2={1} only
cat("--- D2) Update z2 ---\n")
cat("A_xi(u2) = {1} so z2 is forced to 1.\n\n")
z2_new <- 1

#### D3) Update z3, candidates A3={1,2}
cat("--- D3) Update z3 ---\n")
x <- x3
eta <- eta3

m31 <- mu[1] + lambda[1]*eta
m32 <- mu[2] + lambda[2]*eta

d31 <- dnorm(x, mean=m31, sd=sqrt(psi[1]))
d32 <- dnorm(x, mean=m32, sd=sqrt(psi[2]))

w31 <- coef[1]*d31
w32 <- coef[2]*d32

wsum <- w31+w32
p31 <- w31/wsum
p32 <- w32/wsum

cat("means: m31=", m31, " m32=", m32, "\n", sep="")
cat("dens : d31=", d31, " d32=", d32, "\n", sep="")
cat("w    : w31=", w31, " w32=", w32, "\n", sep="")
cat("P(z3=1)=", p31, " P(z3=2)=", p32, "\n", sep="")

# Fixed uniform draw r3 = 0.50
r3 <- 0.50
cdf3 <- c(p31, 1.0)
cat("cdf = (", cdf3[1], ", 1)\n", sep="")
cat("r3 = ", r3, "\n", sep="")

if (r3 <= cdf3[1]) {
  z3_new <- 1
} else {
  z3_new <- 2
}
cat("=> z3 <- ", z3_new, "\n\n", sep="")

# Update z
z1 <- z1_new
z2 <- z2_new
z3 <- z3_new
cat("Updated z = (", z1, ", ", z2, ", ", z3, ")\n\n", sep="")

############################################################
cat("=== Step E) Update stick-breaking v_g and weights pi_g (DP, alpha=1) ===\n")
# Occupancies among clusters 1..3
n1 <- sum(c(z1,z2,z3) == 1)
n2 <- sum(c(z1,z2,z3) == 2)
n3 <- sum(c(z1,z2,z3) == 3)
cat("n = (n1=", n1, ", n2=", n2, ", n3=", n3, ")\n", sep="")

# Posterior for DP blocked stick-breaking (finite truncation here at 3 for the demo):
# v_g | z ~ Beta(1+n_g, alpha + sum_{h>g} n_h)
a1 <- 1 + n1
b1 <- alpha + (n2 + n3)
a2 <- 1 + n2
b2 <- alpha + (n3)
a3 <- 1 + n3
b3 <- alpha + 0

cat("v1 | z ~ Beta(", a1, ", ", b1, ")\n", sep="")
cat("v2 | z ~ Beta(", a2, ", ", b2, ")\n", sep="")
cat("v3 | z ~ Beta(", a3, ", ", b3, ")\n", sep="")

# Fixed "draws" to match the example
v1_new <- 0.35
v2_new <- 0.55
v3_new <- 0.80

v <- c(v1_new, v2_new, v3_new)
pi[1] <- v[1]
pi[2] <- v[2]*(1 - v[1])
pi[3] <- v[3]*(1 - v[1])*(1 - v[2])

cat("Draw v = (", v[1], ", ", v[2], ", ", v[3], ")\n", sep="")
cat("New  pi = (", pi[1], ", ", pi[2], ", ", pi[3], ")\n\n", sep="")

############################################################
cat("=== Step F) Update eta_i | .  (using OLD mu/lambda/psi, but NEW z) ===\n")
cat("eta_i|. ~ N(m_i, V_g),  V_g=(1+lambda_g^2/psi_g)^(-1),  m_i=V_g*(lambda_g/psi_g)*(x_i-mu_g)\n\n")

# Keep a copy of "old" cluster params for this step
mu_old     <- mu
lambda_old <- lambda
psi_old    <- psi

# Fixed standard normal draws s1,s2,s3
s1 <- -0.5
s2 <-  0.2
s3 <- -0.1

# i=1 (now in cluster z1)
g <- z1
V1 <- 1 / (1 + (lambda_old[g]^2)/psi_old[g])
m1 <- V1 * (lambda_old[g]/psi_old[g]) * (x1 - mu_old[g])
eta1 <- m1 + sqrt(V1)*s1
cat("i=1, g=", g, ": V=", V1, " m=", m1, " eta1<-", eta1, "\n", sep="")

# i=2
g <- z2
V2 <- 1 / (1 + (lambda_old[g]^2)/psi_old[g])
m2 <- V2 * (lambda_old[g]/psi_old[g]) * (x2 - mu_old[g])
eta2 <- m2 + sqrt(V2)*s2
cat("i=2, g=", g, ": V=", V2, " m=", m2, " eta2<-", eta2, "\n", sep="")

# i=3
g <- z3
V3 <- 1 / (1 + (lambda_old[g]^2)/psi_old[g])
m3 <- V3 * (lambda_old[g]/psi_old[g]) * (x3 - mu_old[g])
eta3 <- m3 + sqrt(V3)*s3
cat("i=3, g=", g, ": V=", V3, " m=", m3, " eta3<-", eta3, "\n\n", sep="")

cat("Updated eta = (", eta1, ", ", eta2, ", ", eta3, ")\n\n", sep="")

############################################################
cat("=== Step G) Update mu_g | .  (using OLD lambda/psi, NEW eta, NEW z) ===\n")
cat("mu_g|. ~ N(mbar_g, Vbar_g), Vbar_g=(1+n_g/psi_g)^(-1), mbar_g=Vbar_g*(1/psi_g)*sum_{i in I_g}(x_i-lambda_g*eta_i)\n\n")

# Fixed standard normal draws t1,t2,t3 for mu updates
t1 <-  0.3
t2 <- -0.2
t3 <-  0.1

# Cluster 1: I1 contains which samples?
# Here z=(3,1,2), so cluster 1 has sample i=2 only
g <- 1
ng <- n1
Vbar1 <- 1 / (1 + ng/psi_old[g])
sum1 <- (x2 - lambda_old[g]*eta2)
mbar1 <- Vbar1 * (1/psi_old[g]) * sum1
mu[1] <- mbar1 + sqrt(Vbar1)*t1
cat("g=1: Vbar=", Vbar1, " mbar=", mbar1, " mu1<-", mu[1], "\n", sep="")

# Cluster 2 has sample i=3 only
g <- 2
ng <- n2
Vbar2 <- 1 / (1 + ng/psi_old[g])
sum2 <- (x3 - lambda_old[g]*eta3)
mbar2 <- Vbar2 * (1/psi_old[g]) * sum2
mu[2] <- mbar2 + sqrt(Vbar2)*t2
cat("g=2: Vbar=", Vbar2, " mbar=", mbar2, " mu2<-", mu[2], "\n", sep="")

# Cluster 3 has sample i=1 only
g <- 3
ng <- n3
Vbar3 <- 1 / (1 + ng/psi_old[g])
sum3 <- (x1 - lambda_old[g]*eta1)
mbar3 <- Vbar3 * (1/psi_old[g]) * sum3
mu[3] <- mbar3 + sqrt(Vbar3)*t3
cat("g=3: Vbar=", Vbar3, " mbar=", mbar3, " mu3<-", mu[3], "\n\n", sep="")

############################################################
cat("=== Step H) Update lambda_g | .  (using OLD psi, NEW mu, NEW eta, NEW z) ===\n")
cat("lambda_g|. ~ N(mlam_g, Vlam_g), Vlam_g=(1+(1/psi_g)*sum eta_i^2)^(-1), mlam_g=Vlam_g*(1/psi_g)*sum eta_i*(x_i-mu_g)\n\n")

# Fixed standard normal draws rlam1, rlam2, rlam3
rlam1 <- -0.4
rlam2 <-  0.2
rlam3 <-  0.1

# Cluster 1 has i=2
g <- 1
Vlam1 <- 1 / (1 + (1/psi_old[g]) * (eta2^2))
mlam1 <- Vlam1 * (1/psi_old[g]) * (eta2 * (x2 - mu[g]))
lambda[1] <- mlam1 + sqrt(Vlam1)*rlam1
cat("g=1: Vlam=", Vlam1, " mlam=", mlam1, " lambda1<-", lambda[1], "\n", sep="")

# Cluster 2 has i=3
g <- 2
Vlam2 <- 1 / (1 + (1/psi_old[g]) * (eta3^2))
mlam2 <- Vlam2 * (1/psi_old[g]) * (eta3 * (x3 - mu[g]))
lambda[2] <- mlam2 + sqrt(Vlam2)*rlam2
cat("g=2: Vlam=", Vlam2, " mlam=", mlam2, " lambda2<-", lambda[2], "\n", sep="")

# Cluster 3 has i=1
g <- 3
Vlam3 <- 1 / (1 + (1/psi_old[g]) * (eta1^2))
mlam3 <- Vlam3 * (1/psi_old[g]) * (eta1 * (x1 - mu[g]))
lambda[3] <- mlam3 + sqrt(Vlam3)*rlam3
cat("g=3: Vlam=", Vlam3, " mlam=", mlam3, " lambda3<-", lambda[3], "\n\n", sep="")

############################################################
cat("=== Step I) Update psi_g | .  (using NEW mu, NEW lambda, NEW eta, NEW z) ===\n")
cat("psi_g|. ~ IG(a0+n_g/2, b0+0.5*sum (x_i-mu_g-lambda_g*eta_i)^2)\n\n")

# Residuals (each cluster has one point in this demo)
e1 <- x2 - mu[1] - lambda[1]*eta2
e2 <- x3 - mu[2] - lambda[2]*eta3
e3 <- x1 - mu[3] - lambda[3]*eta1

cat("Residuals: e1=", e1, " e2=", e2, " e3=", e3, "\n", sep="")
cat("Squares  : e1^2=", e1^2, " e2^2=", e2^2, " e3^2=", e3^2, "\n\n", sep="")

a_post <- a0 + 1/2  # since n_g=1 for each
b1_post <- b0 + 0.5*(e1^2)
b2_post <- b0 + 0.5*(e2^2)
b3_post <- b0 + 0.5*(e3^2)

cat("Posterior IG params:\n")
cat("g=1: a=", a_post, " b=", b1_post, "\n", sep="")
cat("g=2: a=", a_post, " b=", b2_post, "\n", sep="")
cat("g=3: a=", a_post, " b=", b3_post, "\n\n", sep="")

# Use y=1/psi ~ Gamma(a, rate=b); fixed draws y1,y2,y3 to match example
y1 <- 2.222
y2 <- 3.571
y3 <- 1.667

psi[1] <- 1/y1
psi[2] <- 1/y2
psi[3] <- 1/y3

cat("Fixed Gamma draws: y=(2.222, 3.571, 1.667)\n")
cat("Updated psi = (", psi[1], ", ", psi[2], ", ", psi[3], ")\n\n", sep="")

############################################################
cat("=== End of one sweep: new state ===\n")
cat("z   = (", z1, ", ", z2, ", ", z3, ")\n", sep="")
cat("eta = (", eta1, ", ", eta2, ", ", eta3, ")\n", sep="")
cat("mu  = (", mu[1], ", ", mu[2], ", ", mu[3], ")\n", sep="")
cat("lam = (", lambda[1], ", ", lambda[2], ", ", lambda[3], ")\n", sep="")
cat("psi = (", psi[1], ", ", psi[2], ", ", psi[3], ")\n", sep="")
cat("pi  = (", pi[1], ", ", pi[2], ", ", pi[3], ")\n", sep="")

```